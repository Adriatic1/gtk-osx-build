From a601126aa92db1da327298d2bcc94764a356ea52 Mon Sep 17 00:00:00 2001
From: John Ralls <jralls@ceridwen.us>
Date: Fri, 9 Sep 2011 10:12:40 +0200
Subject: [PATCH 10/15] Bug 617583 - Dead accents keys don't work in GTK+
 applications on OSX

Handle dead keys in special_ucs_table and have them converted by
UCKeyTranslate(), so all dead key combinations can be entered.
Later, this should be handled in the input method, just as it's
done for X11/Win32.
---
 gdk/quartz/gdkkeys-quartz.c |   77 ++++++++++++++++++++++++++++++++++++++++---
 1 files changed, 72 insertions(+), 5 deletions(-)

diff --git a/gdk/quartz/gdkkeys-quartz.c b/gdk/quartz/gdkkeys-quartz.c
index 52b0867..8c7e6f1 100644
--- a/gdk/quartz/gdkkeys-quartz.c
+++ b/gdk/quartz/gdkkeys-quartz.c
@@ -182,7 +182,60 @@ const static struct {
   { 0x001d, GDK_Right },
   { 0x001e, GDK_Up },
   { 0x001f, GDK_Down },
-  { 0x007f, GDK_Delete }
+  { 0x007f, GDK_Delete },
+  { 0xf027, GDK_dead_acute },
+  { 0xf060, GDK_dead_grave },
+  { 0xf300, GDK_dead_grave },
+  { 0xf0b4, GDK_dead_acute },
+  { 0xf301, GDK_dead_acute },
+  { 0xf385, GDK_dead_acute },
+  { 0xf05e, GDK_dead_circumflex },
+  { 0xf2c6, GDK_dead_circumflex },
+  { 0xf302, GDK_dead_circumflex },
+  { 0xf07e, GDK_dead_tilde },
+  { 0xf303, GDK_dead_tilde },
+  { 0xf342, GDK_dead_perispomeni },
+  { 0xf0af, GDK_dead_macron },
+  { 0xf304, GDK_dead_macron },
+  { 0xf2d8, GDK_dead_breve },
+  { 0xf306, GDK_dead_breve },
+  { 0xf2d9, GDK_dead_abovedot },
+  { 0xf307, GDK_dead_abovedot },
+  { 0xf0a8, GDK_dead_diaeresis },
+  { 0xf308, GDK_dead_diaeresis },
+  { 0xf2da, GDK_dead_abovering },
+  { 0xf30A, GDK_dead_abovering },
+  { 0xf022, GDK_dead_doubleacute },
+  { 0xf2dd, GDK_dead_doubleacute },
+  { 0xf30B, GDK_dead_doubleacute },
+  { 0xf2c7, GDK_dead_caron },
+  { 0xf30C, GDK_dead_caron },
+  { 0xf0be, GDK_dead_cedilla },
+  { 0xf327, GDK_dead_cedilla },
+  { 0xf2db, GDK_dead_ogonek },
+  { 0xf328, GDK_dead_ogonek },
+  { 0xfe5d, GDK_dead_iota },
+  { 0xf323, GDK_dead_belowdot },
+  { 0xf309, GDK_dead_hook },
+  { 0xf31B, GDK_dead_horn },
+  { 0xf02d, GDK_dead_stroke },
+  { 0xf335, GDK_dead_stroke },
+  { 0xf336, GDK_dead_stroke },
+  { 0xf313, GDK_dead_abovecomma },
+  /*  { 0xf313, GDK_dead_psili }, */
+  { 0xf314, GDK_dead_abovereversedcomma },
+  /*  { 0xf314, GDK_dead_dasia }, */
+  { 0xf30F, GDK_dead_doublegrave },
+  { 0xf325, GDK_dead_belowring },
+  { 0xf2cd, GDK_dead_belowmacron },
+  { 0xf331, GDK_dead_belowmacron },
+  { 0xf32D, GDK_dead_belowcircumflex },
+  { 0xf330, GDK_dead_belowtilde },
+  { 0xf32E, GDK_dead_belowbreve },
+  { 0xf324, GDK_dead_belowdiaeresis },
+  { 0xf311, GDK_dead_invertedbreve },
+  { 0xf02c, GDK_dead_belowcomma },
+  { 0xf326, GDK_dead_belowcomma }
 };
 
 static void
@@ -330,10 +383,10 @@ maybe_update_keymap (void)
 		  UniChar uc;
 		  
 		  key_code = modifiers[j] | i;
-		  err = UCKeyTranslate (chr_data, i, kUCKeyActionDown,
+		  err = UCKeyTranslate (chr_data, i, kUCKeyActionDisplay,
 		                        (modifiers[j] >> 8) & 0xFF,
 		                        LMGetKbdType(),
-		                        kUCKeyTranslateNoDeadKeysMask,
+		                        0,
 		                        &state, 4, &nChars, chars);
 
 
@@ -345,8 +398,22 @@ maybe_update_keymap (void)
 		    {
 		      int k;
 		      gboolean found = FALSE;
-		      
-		      uc = chars[0];
+
+		      /* A few <Shift><Option>keys return two
+		       * characters, the first of which is U+00a0,
+		       * which isn't interesting; so we return the
+		       * second. More sophisticated handling is the
+		       * job of a GtkIMContext.
+		       *
+		       * If state isn't zero, it means that it's a
+		       * dead key of some sort. Some of those are
+		       * enumerated in the special_ucs_table with the
+		       * high nibble set to f to push it into the
+		       * private use range. Here we do the same.
+		       */
+		      if (state != 0)
+			chars[nChars - 1] |= 0xf000;
+		      uc = chars[nChars - 1];
 
 		      for (k = 0; k < G_N_ELEMENTS (special_ucs_table); k++) 
 			{

